import * as chrome from "./chrome";
import * as edge from "./edge";
import * as firefox from "./firefox";
import * as ie from "./ie";
import * as opera from "./opera";
import * as safari from "./safari";

export namespace error {
    class IError extends Error {
        constructor(opt_error?: string);
    }

    /**
     * The base WebDriver error type. This error type is only used directly when a
     * more appropriate category is not defined for the offending error.
     */
    class WebDriverError extends IError {
        /** @param {string=} opt_error the error message, if any. */
        constructor(opt_error?: string);
    }

    /**
     * An attempt was made to select an element that cannot be selected.
     */
    class ElementNotSelectableError extends WebDriverError {
        /** @param {string=} opt_error the error message, if any. */
        constructor(opt_error?: string);
    }

    /**
     * An element command could not be completed because the element is not visible
     * on the page.
     */
    class ElementNotVisibleError extends WebDriverError {
        /** @param {string=} opt_error the error message, if any. */
        constructor(opt_error?: string);
    }

    /**
     * The arguments passed to a command are either invalid or malformed.
     */
    class InvalidArgumentError extends WebDriverError {
        /** @param {string=} opt_error the error message, if any. */
        constructor(opt_error?: string);
    }

    /**
     * An illegal attempt was made to set a cookie under a different domain than
     * the current page.
     */
    class InvalidCookieDomainError extends WebDriverError {
        /** @param {string=} opt_error the error message, if any. */
        constructor(opt_error?: string);
    }

    /**
     * The coordinates provided to an interactions operation are invalid.
     */
    class InvalidElementCoordinatesError extends WebDriverError {
        /** @param {string=} opt_error the error message, if any. */
        constructor(opt_error?: string);
    }

    /**
     * An element command could not be completed because the element is in an
     * invalid state, e.g. attempting to click an element that is no longer attached
     * to the document.
     */
    class InvalidElementStateError extends WebDriverError {
        /** @param {string=} opt_error the error message, if any. */
        constructor(opt_error?: string);
    }

    /**
     * Argument was an invalid selector.
     */
    class InvalidSelectorError extends WebDriverError {
        /** @param {string=} opt_error the error message, if any. */
        constructor(opt_error?: string);
    }

    /**
     * Occurs when a command is directed to a session that does not exist.
     */
    class NoSuchSessionError extends WebDriverError {
        /** @param {string=} opt_error the error message, if any. */
        constructor(opt_error?: string);
    }

    /**
     * An error occurred while executing JavaScript supplied by the user.
     */
    class JavascriptError extends WebDriverError {
        /** @param {string=} opt_error the error message, if any. */
        constructor(opt_error?: string);
    }

    /**
     * The target for mouse interaction is not in the browser’s viewport and cannot
     * be brought into that viewport.
     */
    class MoveTargetOutOfBoundsError extends WebDriverError {
        /** @param {string=} opt_error the error message, if any. */
        constructor(opt_error?: string);
    }

    /**
     * An attempt was made to operate on a modal dialog when one was not open.
     */
    class NoSuchAlertError extends WebDriverError {
        /** @param {string=} opt_error the error message, if any. */
        constructor(opt_error?: string);
    }

    /**
     * An element could not be located on the page using the given search
     * parameters.
     */
    class NoSuchElementError extends WebDriverError {
        /** @param {string=} opt_error the error message, if any. */
        constructor(opt_error?: string);
    }

    /**
     * A request to switch to a frame could not be satisfied because the frame
     * could not be found.
     */
    class NoSuchFrameError extends WebDriverError {
        /** @param {string=} opt_error the error message, if any. */
        constructor(opt_error?: string);
    }

    /**
     * A request to switch to a window could not be satisfied because the window
     * could not be found.
     */
    class NoSuchWindowError extends WebDriverError {
        /** @param {string=} opt_error the error message, if any. */
        constructor(opt_error?: string);
    }

    /**
     * A script did not complete before its timeout expired.
     */
    class ScriptTimeoutError extends WebDriverError {
        /** @param {string=} opt_error the error message, if any. */
        constructor(opt_error?: string);
    }

    /**
     * A new session could not be created.
     */
    class SessionNotCreatedError extends WebDriverError {
        /** @param {string=} opt_error the error message, if any. */
        constructor(opt_error?: string);
    }

    /**
     * An element command failed because the referenced element is no longer
     * attached to the DOM.
     */
    class StaleElementReferenceError extends WebDriverError {
        /** @param {string=} opt_error the error message, if any. */
        constructor(opt_error?: string);
    }

    /**
     * An operation did not completErrorCodee before its timeout expired.
     */
    class TimeoutError extends WebDriverError {
        /** @param {string=} opt_error the error message, if any. */
        constructor(opt_error?: string);
    }

    /**
     * A request to set a cookie’s value could not be satisfied.
     */
    class UnableToSetCookieError extends WebDriverError {
        /** @param {string=} opt_error the error message, if any. */
        constructor(opt_error?: string);
    }

    /**
     * A screen capture operation was not possible.
     */
    class UnableToCaptureScreenError extends WebDriverError {
        /** @param {string=} opt_error the error message, if any. */
        constructor(opt_error?: string);
    }

    /**
     * A modal dialog was open, blocking this operation.
     */
    class UnexpectedAlertOpenError extends WebDriverError {
        /**
         * @param {string=} opt_error the error message, if any.
         * @param {string=} opt_text the text of the open dialog, if available.
         */
        constructor(opt_error?: string, opt_text?: string);

        /**
         * @return {(string|undefined)} The text displayed with the unhandled alert,
         *     if available.
         */
        getAlertText(): string;
    }

    /**
     * A command could not be executed because the remote end is not aware of it.
     */
    class UnknownCommandError extends WebDriverError {
        /** @param {string=} opt_error the error message, if any. */
        constructor(opt_error?: string);
    }

    /**
     * The requested command matched a known URL but did not match an method for
     * that URL.
     */
    class UnknownMethodError extends WebDriverError {
        /** @param {string=} opt_error the error message, if any. */
        constructor(opt_error?: string);
    }

    /**
     * Reports an unsupport operation.
     */
    class UnsupportedOperationError extends WebDriverError {
        /** @param {string=} opt_error the error message, if any. */
        constructor(opt_error?: string);
    }
}

export namespace logging {
    /**
     * A hash describing log preferences.
     */
    class Preferences {
        setLevel(type: string, level: Level | string | number): void;
        toJSON(): { [key: string]: string };
    }

    interface IType {
        /** Logs originating from the browser. */
        BROWSER: string;
        /** Logs from a WebDriver client. */
        CLIENT: string;
        /** Logs from a WebDriver implementation. */
        DRIVER: string;
        /** Logs related to performance. */
        PERFORMANCE: string;
        /** Logs from the remote server. */
        SERVER: string;
    }

    /**
     * Common log types.
     */
    const Type: IType;

    /**
     * Defines a message level that may be used to control logging output.
     *
     * @final
     */
    class Level {
        name_: string;
        value_: number;
        /**
         * @param {string} name the level's name.
         * @param {number} level the level's numeric value.
         */
        constructor(name: string, level: number);

        /** @override */
        toString(): string;

        /** This logger's name. */
        name: string;

        /** The numeric log level. */
        value: number;

        /**
         * Indicates no log messages should be recorded.
         * @constant
         */
        static OFF: Level;
        /**
         * Log messages with a level of `1000` or higher.
         * @constant
         */
        static SEVERE: Level;
        /**
         * Log messages with a level of `900` or higher.
         * @constant
         */
        static WARNING: Level;
        /**
         * Log messages with a level of `800` or higher.
         * @constant
         */
        static INFO: Level;
        /**
         * Log messages with a level of `700` or higher.
         * @constant
         */
        static DEBUG: Level;
        /**
         * Log messages with a level of `500` or higher.
         * @constant
         */
        static FINE: Level;
        /**
         * Log messages with a level of `400` or higher.
         * @constant
         */
        static FINER: Level;
        /**
         * Log messages with a level of `300` or higher.
         * @constant
         */
        static FINEST: Level;
        /**
         * Indicates all log messages should be recorded.
         * @constant
         */
        static ALL: Level;
    }

    /**
     * Converts a level name or value to a {@link logging.Level} value.
     * If the name/value is not recognized, {@link logging.Level.ALL}
     * will be returned.
     * @param {(number|string)} nameOrValue The log level name, or value, to
     *     convert .
     * @return {!logging.Level} The converted level.
     */
    function getLevel(nameOrValue: string | number): Level;

    interface IEntryJSON {
        level: string;
        message: string;
        timestamp: number;
        type: string;
    }

    /**
     * A single log entry.
     */
    class Entry {
        /**
         * @param {(!logging.Level|string)} level The entry level.
         * @param {string} message The log message.
         * @param {number=} opt_timestamp The time this entry was generated, in
         *     milliseconds since 0:00:00, January 1, 1970 UTC. If omitted, the
         *     current time will be used.
         * @param {string=} opt_type The log type, if known.
         */
        constructor(level: Level | string | number, message: string, opt_timestamp?: number, opt_type?: string | IType);

        level: Level;

        message: string;

        timestamp: number;

        type: string;

        /**
         * @return {{level: string, message: string, timestamp: number,
         *           type: string}} The JSON representation of this entry.
         */
        toJSON(): IEntryJSON;
    }

    /**
     * An object used to log debugging messages. Loggers use a hierarchical,
     * dot-separated naming scheme. For instance, 'foo' is considered the parent of
     * the 'foo.bar' and an ancestor of 'foo.bar.baz'.
     *
     * Each logger may be assigned a {@linkplain #setLevel log level}, which
     * controls which level of messages will be reported to the
     * {@linkplain #addHandler handlers} attached to this instance. If a log level
     * is not explicitly set on a logger, it will inherit its parent.
     *
     * This class should never be directly instantiated. Instead, users should
     * obtain logger references using the {@linkplain ./logging.getLogger()
     * getLogger()} function.
     *
     * @final
     */
    class Logger {
        /**
         * @param {string} name the name of this logger.
         * @param {Level=} opt_level the initial level for this logger.
         */
        constructor(name: string, opt_level?: Level);

        name_: string;
        level_: Level;
        parent_: Logger;
        handlers_: any;

        /** @return {string} the name of this logger. */
        getName(): string;

        /**
         * @param {Level} level the new level for this logger, or `null` if the logger
         *     should inherit its level from its parent logger.
         */
        setLevel(level: Level): void;

        /** @return {Level} the log level for this logger. */
        getLevel(): Level;

        /**
         * @return {!Level} the effective level for this logger.
         */
        getEffectiveLevel(): Level;

        /**
         * @param {!Level} level the level to check.
         * @return {boolean} whether messages recorded at the given level are loggable
         *     by this instance.
         */
        isLoggable(level: Level): boolean;

        /**
         * Adds a handler to this logger. The handler will be invoked for each message
         * logged with this instance, or any of its descendants.
         *
         * @param {function(!Entry)} handler the handler to add.
         */
        addHandler(handler: any): void;

        /**
         * Removes a handler from this logger.
         *
         * @param {function(!Entry)} handler the handler to remove.
         * @return {boolean} whether a handler was successfully removed.
         */
        removeHandler(handler: any): void;

        /**
         * Logs a message at the given level. The message may be defined as a string
         * or as a function that will return the message. If a function is provided,
         * it will only be invoked if this logger's
         * {@linkplain #getEffectiveLevel() effective log level} includes the given
         * `level`.
         *
         * @param {!Level} level the level at which to log the message.
         * @param {(string|function(): string)} loggable the message to log, or a
         *     function that will return the message.
         */
        log(level: Level, loggable: string | Function): void;

        /**
         * Logs a message at the {@link Level.SEVERE} log level.
         * @param {(string|function(): string)} loggable the message to log, or a
         *     function that will return the message.
         */
        severe(loggable: string | Function): void;

        /**
         * Logs a message at the {@link Level.WARNING} log level.
         * @param {(string|function(): string)} loggable the message to log, or a
         *     function that will return the message.
         */
        warning(loggable: string | Function): void;

        /**
         * Logs a message at the {@link Level.INFO} log level.
         * @param {(string|function(): string)} loggable the message to log, or a
         *     function that will return the message.
         */
        info(loggable: string | Function): void;

        /**
         * Logs a message at the {@link Level.DEBUG} log level.
         * @param {(string|function(): string)} loggable the message to log, or a
         *     function that will return the message.
         */
        debug(loggable: string | Function): void;

        /**
         * Logs a message at the {@link Level.FINE} log level.
         * @param {(string|function(): string)} loggable the message to log, or a
         *     function that will return the message.
         */
        fine(loggable: string | Function): void;

        /**
         * Logs a message at the {@link Level.FINER} log level.
         * @param {(string|function(): string)} loggable the message to log, or a
         *     function that will return the message.
         */
        finer(loggable: string | Function): void;

        /**
         * Logs a message at the {@link Level.FINEST} log level.
         * @param {(string|function(): string)} loggable the message to log, or a
         *     function that will return the message.
         */
        finest(loggable: string | Function): void;
    }

    /**
     * Maintains a collection of loggers.
     *
     * @final
     */
    class LogManager {
        /**
         * Retrieves a named logger, creating it in the process. This function will
         * implicitly create the requested logger, and any of its parents, if they
         * do not yet exist.
         *
         * @param {string} name the logger's name.
         * @return {!Logger} the requested logger.
         */
        getLogger(name?: string): Logger;

        /**
         * Creates a new logger.
         *
         * @param {string} name the logger's name.
         * @param {!Logger} parent the logger's parent.
         * @return {!Logger} the new logger.
         */
        createLogger_(name: string, parent: Logger): Logger;
    }

    /**
     * Retrieves a named logger, creating it in the process. This function will
     * implicitly create the requested logger, and any of its parents, if they
     * do not yet exist.
     *
     * @param {string} name the logger's name.
     * @return {!Logger} the requested logger.
     */
    function getLogger(name?: string): Logger;

    /**
     * Adds the console handler to the given logger. The console handler will log
     * all messages using the JavaScript Console API.
     *
     * @param {Logger=} opt_logger The logger to add the handler to; defaults
     *     to the root logger.
     */
    function addConsoleHandler(opt_logger?: Logger): void;

    /**
     * Removes the console log handler from the given logger.
     *
     * @param {Logger=} opt_logger The logger to remove the handler from; defaults
     *     to the root logger.
     * @see exports.addConsoleHandler
     */
    function removeConsoleHandler(opt_logger?: Logger): void;
}

export namespace promise {
    // region Functions

    /**
     * Set `USE_PROMISE_MANAGER` to `false` to disable the promise manager.
     * This is useful, if you use async/await (see https://github.com/SeleniumHQ/selenium/issues/2969
     * and https://github.com/SeleniumHQ/selenium/issues/3037).
     */
    let USE_PROMISE_MANAGER: boolean;

    /**
     * Given an array of promises, will return a promise that will be fulfilled
     * with the fulfillment values of the input array's values. If any of the
     * input array's promises are rejected, the returned promise will be rejected
     * with the same reason.
     *
     * @param {!Array<(T|!ManagedPromise<T>)>} arr An array of
     *     promises to wait on.
     * @return {!ManagedPromise<!T[]>} A promise that is
     *     fulfilled with an array containing the fulfilled values of the
     *     input array, or rejected with the same reason as the first
     *     rejected value.
     * @template T
     */
    function all<T>(arr: Array<T | Promise<T>>): Promise<T[]>;

    /**
     * Invokes the appropriate callback function as soon as a promised
     * {@code value} is resolved. This function is similar to
     * {@link promise.when}, except it does not return a new promise.
     * @param {*} value The value to observe.
     * @param {Function} callback The function to call when the value is
     *     resolved successfully.
     * @param {Function=} opt_errback The function to call when the value is
     *     rejected.
     */
    function asap(value: any, callback: Function, opt_errback?: Function): void;

    /**
     * @return {!promise.ControlFlow} The currently active control flow.
     */
    function controlFlow(): ControlFlow;

    /**
     * Creates a new control flow. The provided callback will be invoked as the
     * first task within the new flow, with the flow as its sole argument. Returns
     * a promise that resolves to the callback result.
     * @param {function(!ControlFlow)} callback The entry point
     *     to the newly created flow.
     * @return {!ManagedPromise} A promise that resolves to the callback
     *     result.
     */
    function createFlow<R>(callback: (flow: ControlFlow) => R): Promise<R>;

    /**
     * Determines whether a {@code value} should be treated as a promise.
     * Any object whose 'then' property is a function will be considered a promise.
     *
     * @param {*} value The value to test.
     * @return {boolean} Whether the value is a promise.
     */
    function isPromise(value: any): boolean;

    /**
     * Tests is a function is a generator.
     * @param {!Function} fn The function to test.
     * @return {boolean} Whether the function is a generator.
     */
    function isGenerator(fn: Function): boolean;

    /**
     * Creates a promise that will be resolved at a set time in the future.
     * @param {number} ms The amount of time, in milliseconds, to wait before
     *     resolving the promise.
     * @return {!ManagedPromise} The promise.
     */
    function delayed(ms: number): Promise<void>;

    /**
     * Calls a function for each element in an array, and if the function returns
     * true adds the element to a new array.
     *
     * If the return value of the filter function is a promise, this function
     * will wait for it to be fulfilled before determining whether to insert the
     * element into the new array.
     *
     * If the filter function throws or returns a rejected promise, the promise
     * returned by this function will be rejected with the same reason. Only the
     * first failure will be reported; all subsequent errors will be silently
     * ignored.
     *
     * @param {!(Array<TYPE>|ManagedPromise<!Array<TYPE>>)} arr The
     *     array to iterator over, or a promise that will resolve to said array.
     * @param {function(this: SELF, TYPE, number, !Array<TYPE>): (
     *             boolean|ManagedPromise<boolean>)} fn The function
     *     to call for each element in the array.
     * @param {SELF=} opt_self The object to be used as the value of 'this' within
     *     {@code fn}.
     * @template TYPE, SELF
     */
    function filter<T>(
        arr: T[] | Promise<T[]>,
        fn: (element: T, type: any, index: number, array: T[]) => any,
        opt_self?: any,
    ): Promise<T[]>;

    /**
     * Creates a new deferred object.
     * @return {!promise.Deferred} The new deferred object.
     */
    function defer<T>(): Deferred<T>;

    /**
     * Creates a promise that has been resolved with the given value.
     * @param {T=} opt_value The resolved value.
     * @return {!Promise<T>} The resolved promise.
     * @deprecated Use {@link Promise#resolve Promise.resolve(value)}.
     * @template T
     */
    function fulfilled<T>(opt_value?: T): Promise<T>;

    /**
     * Calls a function for each element in an array and inserts the result into a
     * new array, which is used as the fulfillment value of the promise returned
     * by this function.
     *
     * If the return value of the mapping function is a promise, this function
     * will wait for it to be fulfilled before inserting it into the new array.
     *
     * If the mapping function throws or returns a rejected promise, the
     * promise returned by this function will be rejected with the same reason.
     * Only the first failure will be reported; all subsequent errors will be
     * silently ignored.
     *
     * @param {!(Array<TYPE>|ManagedPromise<!Array<TYPE>>)} arr The
     *     array to iterator over, or a promise that will resolve to said array.
     * @param {function(this: SELF, TYPE, number, !Array<TYPE>): ?} fn The
     *     function to call for each element in the array. This function should
     *     expect three arguments (the element, the index, and the array itself.
     * @param {SELF=} opt_self The object to be used as the value of 'this' within
     *     {@code fn}.
     * @template TYPE, SELF
     */
    function map<T>(
        arr: T[] | Promise<T[]>,
        fn: (self: any, type: any, index: number, array: T[]) => any,
        opt_self?: any,
    ): Promise<any[]>;

    /**
     * Creates a promise that has been rejected with the given reason.
     * @param {*=} opt_reason The rejection reason; may be any value, but is
     *     usually an Error or a string.
     * @return {!Promise<?>} The rejected promise.
     * @deprecated Use {@link Promise#reject Promise.Promise(reason)}.
     */
    function rejected<T>(opt_reason?: any): Promise<T>;

    /**
     * Wraps a function that expects a node-style callback as its final
     * argument. This callback expects two arguments: an error value (which will be
     * null if the call succeeded), and the success value as the second argument.
     * The callback will the resolve or reject the returned promise, based on its
     * arguments.
     * @param {!Function} fn The function to wrap.
     * @param {...?} var_args The arguments to apply to the function, excluding the
     *     final callback.
     * @return {!ManagedPromise} A promise that will be resolved with the
     *     result of the provided function's callback.
     */
    function checkedNodeCall<T>(fn: Function, ...var_args: any[]): Promise<T>;

    /**
     * Consumes a {@code GeneratorFunction}. Each time the generator yields a
     * promise, this function will wait for it to be fulfilled before feeding the
     * fulfilled value back into {@code next}. Likewise, if a yielded promise is
     * rejected, the rejection error will be passed to {@code throw}.
     *
     * __Example 1:__ the Fibonacci Sequence.
     *
     *     promise.consume(function* fibonacci() {
     *       var n1 = 1, n2 = 1;
     *       for (var i = 0; i < 4; ++i) {
     *         var tmp = yield n1 + n2;
     *         n1 = n2;
     *         n2 = tmp;
     *       }
     *       return n1 + n2;
     *     }).then(function(result) {
     *       console.log(result);  // 13
     *     });
     *
     * __Example 2:__ a generator that throws.
     *
     *     promise.consume(function* () {
     *       yield promise.delayed(250).then(function() {
     *         throw Error('boom');
     *       });
     *     }).catch(function(e) {
     *       console.log(e.toString());  // Error: boom
     *     });
     *
     * @param {!Function} generatorFn The generator function to execute.
     * @param {Object=} opt_self The object to use as 'this' when invoking the
     *     initial generator.
     * @param {...*} var_args Any arguments to pass to the initial generator.
     * @return {!ManagedPromise<?>} A promise that will resolve to the
     *     generator's final result.
     * @throws {TypeError} If the given function is not a generator.
     */
    function consume<T>(generatorFn: (...args: any[]) => T, opt_self?: any, ...var_args: any[]): Promise<T>;

    /**
     * Registers an observer on a promised {@code value}, returning a new promise
     * that will be resolved when the value is. If {@code value} is not a promise,
     * then the return promise will be immediately resolved.
     * @param {*} value The value to observe.
     * @param {Function=} opt_callback The function to call when the value is
     *     resolved successfully.
     * @param {Function=} opt_errback The function to call when the value is
     *     rejected.
     * @return {!ManagedPromise} A new promise.
     */
    function when<T>(
        value: T | Promise<T>,
        opt_callback?: (value: T) => any,
        opt_errback?: (error: any) => any,
    ): Promise<any>;

    /**
     * Returns a promise that will be resolved with the input value in a
     * fully-resolved state. If the value is an array, each element will be fully
     * resolved. Likewise, if the value is an object, all keys will be fully
     * resolved. In both cases, all nested arrays and objects will also be
     * fully resolved.  All fields are resolved in place; the returned promise will
     * resolve on {@code value} and not a copy.
     *
     * Warning: This function makes no checks against objects that contain
     * cyclical references:
     *
     *     var value = {};
     *     value['self'] = value;
     *     promise.fullyResolved(value);  // Stack overflow.
     *
     * @param {*} value The value to fully resolve.
     * @return {!ManagedPromise} A promise for a fully resolved version
     *     of the input value.
     */
    function fullyResolved<T>(value: any): Promise<T>;

    /**
     * Changes the default flow to use when no others are active.
     * @param {!ControlFlow} flow The new default flow.
     * @throws {Error} If the default flow is not currently active.
     */
    function setDefaultFlow(flow: ControlFlow): void;

    // endregion

    /**
     * Error used when the computation of a promise is cancelled.
     */
    class CancellationError extends Error {
        /**
         * @param {string=} opt_msg The cancellation message.
         */
        constructor(opt_msg?: string);
    }

    interface IThenable<T> extends PromiseLike<T> {
        /**
         * Registers listeners for when this instance is resolved.
         *
         * @param onfulfilled
         *     The function to call if this promise is successfully resolved. The function
         *     should expect a single argument: the promise's resolved value.
         * @param onrejected
         *     The function to call if this promise is rejected. The function should
         *     expect a single argument: the rejection reason.
         * @return A new promise which will be resolved with the result
         *     of the invoked callback.
         * @template R
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
        ): PromiseLike<TResult1 | TResult2>;

        /**
         * Registers a listener for when this promise is rejected. This is synonymous
         * with the {@code catch} clause in a synchronous API:
         *
         *     // Synchronous API:
         *     try {
         *       doSynchronousWork();
         *     } catch (ex) {
         *       console.error(ex);
         *     }
         *
         *     // Asynchronous promise API:
         *     doAsynchronousWork().catch(function(ex) {
         *       console.error(ex);
         *     });
         *
         * @param {function(*): (R|IThenable<R>)} errback The
         *     function to call if this promise is rejected. The function should
         *     expect a single argument: the rejection reason.
         * @return {!ManagedPromise<R>} A new promise which will be
         *     resolved with the result of the invoked callback.
         * @template R
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
        ): Promise<T | TResult>;
    }

    /**
     * Thenable is a promise-like object with a {@code then} method which may be
     * used to schedule callbacks on a promised value.
     *
     * @interface
     * @template T
     */
    interface Thenable<T> extends IThenable<T> {}
    class Thenable<T> {
        /**
         * Registers a listener to invoke when this promise is resolved, regardless
         * of whether the promise's value was successfully computed. This function
         * is synonymous with the {@code finally} clause in a synchronous API:
         *
         *     // Synchronous API:
         *     try {
         *       doSynchronousWork();
         *     } finally {
         *       cleanUp();
         *     }
         *
         *     // Asynchronous promise API:
         *     doAsynchronousWork().finally(cleanUp);
         *
         * __Note:__ similar to the {@code finally} clause, if the registered
         * callback returns a rejected promise or throws an error, it will silently
         * replace the rejection error (if any) from this promise:
         *
         *     try {
         *       throw Error('one');
         *     } finally {
         *       throw Error('two');  // Hides Error: one
         *     }
         *
         *     promise.rejected(Error('one'))
         *         .finally(function() {
         *           throw Error('two');  // Hides Error: one
         *         });
         *
         * @param {function(): (R|IThenable<R>)} callback The function to call when
         *     this promise is resolved.
         * @return {!ManagedPromise<R>} A promise that will be fulfilled
         *     with the callback result.
         * @template R
         */
        finally<R>(callback: Function): Promise<R>;

        /**
         * Adds a property to a class prototype to allow runtime checks of whether
         * instances of that class implement the Thenable interface. This function
         * will also ensure the prototype's {@code then} function is exported from
         * compiled code.
         * @param {function(new: Thenable, ...?)} ctor The
         *     constructor whose prototype to modify.
         */
        static addImplementation(ctor: Function): void;

        /**
         * Checks if an object has been tagged for implementing the Thenable
         * interface as defined by {@link Thenable.addImplementation}.
         * @param {*} object The object to test.
         * @return {boolean} Whether the object is an implementation of the Thenable
         *     interface.
         */
        static isImplementation(object: any): boolean;
    }

    interface IFulfilledCallback<T> {
        (value: T | IThenable<T> | Thenable<T> | undefined): void;
    }

    interface IRejectedCallback {
        (reason: any): void;
    }

    /**
     * Represents the eventual value of a completed operation. Each promise may be
     * in one of three states: pending, fulfilled, or rejected. Each promise starts
     * in the pending state and may make a single transition to either a
     * fulfilled or rejected state, at which point the promise is considered
     * resolved.
     *
     * @template T
     * @see http://promises-aplus.github.io/promises-spec/
     */
    class Promise<T> implements IThenable<T>, PromiseLike<T> {
        /**
         * @param {function(
         *           function((T|IThenable<T>|Thenable)=),
         *           function(*=))} resolver
         *     Function that is invoked immediately to begin computation of this
         *     promise's value. The function should accept a pair of callback
         *     functions, one for fulfilling the promise and another for rejecting it.
         * @param {ControlFlow=} opt_flow The control flow
         *     this instance was created under. Defaults to the currently active flow.
         */
        constructor(
            resolver: (resolve: IFulfilledCallback<T>, reject: IRejectedCallback) => void,
            opt_flow?: ControlFlow,
        );

        /**
         * Creates a promise that is immediately resolved with the given value.
         *
         * @param {T=} opt_value The value to resolve.
         * @return {!ManagedPromise<T>} A promise resolved with the given value.
         * @template T
         */
        static resolve<T>(opt_value?: T): Promise<T>;

        /**
         * Creates a promise that is immediately rejected with the given reason.
         *
         * @param {*=} opt_reason The rejection reason.
         * @return {!ManagedPromise<?>} A new rejected promise.
         */
        static reject(opt_reason?: any): Promise<never>;

        /**
         * Registers listeners for when this instance is resolved.
         *
         * @param onfulfilled
         *     The function to call if this promise is successfully resolved. The function
         *     should expect a single argument: the promise's resolved value.
         * @param onrejected
         *     The function to call if this promise is rejected. The function should
         *     expect a single argument: the rejection reason.
         * @return A new promise which will be resolved with the result
         *     of the invoked callback.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
        ): Promise<TResult1 | TResult2>;

        /**
         * Registers a listener for when this promise is rejected. This is synonymous
         * with the {@code catch} clause in a synchronous API:
         *
         *     // Synchronous API:
         *     try {
         *       doSynchronousWork();
         *     } catch (ex) {
         *       console.error(ex);
         *     }
         *
         *     // Asynchronous promise API:
         *     doAsynchronousWork().catch(function(ex) {
         *       console.error(ex);
         *     });
         *
         * @param onrejected
         *     The function to call if this promise is rejected. The function should
         *     expect a single argument: the rejection reason.
         * @return A new promise which will be resolved with the result of the invoked callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
        ): Promise<T | TResult>;
    }

    /**
     * Represents a value that will be resolved at some point in the future. This
     * class represents the protected 'producer' half of a Promise - each Deferred
     * has a {@code promise} property that may be returned to consumers for
     * registering callbacks, reserving the ability to resolve the deferred to the
     * producer.
     *
     * <p>If this Deferred is rejected and there are no listeners registered before
     * the next turn of the event loop, the rejection will be passed to the
     * {@link promise.ControlFlow} as an unhandled failure.
     */
    class Deferred<T> {
        // region Constructors

        /**
         * @param {promise.ControlFlow=} opt_flow The control flow
         *     this instance was created under. This should only be provided during
         *     unit tests.
         */
        constructor(opt_flow?: ControlFlow);

        // endregion

        static State_: {
            BLOCKED: number;
            PENDING: number;
            REJECTED: number;
            RESOLVED: number;
        };

        // region Properties

        /**
         * The consumer promise for this instance. Provides protected access to the
         * callback registering functions.
         */
        promise: Promise<T>;

        // endregion

        // region Methods

        /**
         * Rejects this promise. If the error is itself a promise, this instance will
         * be chained to it and be rejected with the error's resolved value.
         * @param {*=} opt_error The rejection reason, typically either a
         *     {@code Error} or a {@code string}.
         */
        reject(opt_error?: any): void;
        errback(opt_error?: any): void;

        /**
         * Resolves this promise with the given value. If the value is itself a
         * promise and not a reference to this deferred, this instance will wait for
         * it before resolving.
         * @param {*=} opt_value The resolved value.
         */
        fulfill(opt_value?: T): void;

        /**
         * Removes all of the listeners previously registered on this deferred.
         * @throws {Error} If this deferred has already been resolved.
         */
        removeAll(): void;

        // endregion
    }

    interface IControlFlowTimer {
        clearInterval(ms: number): void;
        clearTimeout(ms: number): void;
        setInterval(fn: Function, ms: number): number;
        setTimeout(fn: Function, ms: number): number;
    }

    interface IEventType {
        /** Emitted when all tasks have been successfully executed. */
        IDLE: string;

        /** Emitted when a ControlFlow has been reset. */
        RESET: string;

        /** Emitted whenever a new task has been scheduled. */
        SCHEDULE_TASK: string;

        /**
         * Emitted whenever a control flow aborts due to an unhandled promise
         * rejection. This event will be emitted along with the offending rejection
         * reason. Upon emitting this event, the control flow will empty its task
         * queue and revert to its initial state.
         */
        UNCAUGHT_EXCEPTION: string;
    }

    /**
     * Handles the execution of scheduled tasks, each of which may be an
     * asynchronous operation. The control flow will ensure tasks are executed in
     * the ordered scheduled, starting each task only once those before it have
     * completed.
     *
     * Each task scheduled within this flow may return a
     * {@link promise.Promise} to indicate it is an asynchronous
     * operation. The ControlFlow will wait for such promises to be resolved before
     * marking the task as completed.
     *
     * Tasks and each callback registered on a {@link promise.Promise}
     * will be run in their own ControlFlow frame.  Any tasks scheduled within a
     * frame will take priority over previously scheduled tasks. Furthermore, if any
     * of the tasks in the frame fail, the remainder of the tasks in that frame will
     * be discarded and the failure will be propagated to the user through the
     * callback/task's promised result.
     *
     * Each time a ControlFlow empties its task queue, it will fire an
     * {@link promise.ControlFlow.EventType.IDLE IDLE} event. Conversely,
     * whenever the flow terminates due to an unhandled error, it will remove all
     * remaining tasks in its queue and fire an
     * {@link promise.ControlFlow.EventType.UNCAUGHT_EXCEPTION
     * UNCAUGHT_EXCEPTION} event. If there are no listeners registered with the
     * flow, the error will be rethrown to the global error handler.
     *
     * @final
     */
    class ControlFlow extends EventEmitter {
        /** */
        constructor();

        /**
         * Events that may be emitted by an {@link promise.ControlFlow}.
         */
        static EventType: IEventType;

        /**
         * Returns a string representation of this control flow, which is its current
         * {@link #getSchedule() schedule}, sans task stack traces.
         * @return {string} The string representation of this contorl flow.
         * @override
         */
        toString(): string;

        /**
         * Resets this instance, clearing its queue and removing all event listeners.
         */
        reset(): void;

        /**
         * Generates an annotated string describing the internal state of this control
         * flow, including the currently executing as well as pending tasks. If
         * {@code opt_includeStackTraces === true}, the string will include the
         * stack trace from when each task was scheduled.
         * @param {string=} opt_includeStackTraces Whether to include the stack traces
         *     from when each task was scheduled. Defaults to false.
         * @return {string} String representation of this flow's internal state.
         */
        getSchedule(opt_includeStackTraces?: boolean): string;

        /**
         * Schedules a task for execution. If there is nothing currently in the
         * queue, the task will be executed in the next turn of the event loop. If
         * the task function is a generator, the task will be executed using
         * {@link promise.consume}.
         *
         * @param {function(): (T|promise.Promise<T>)} fn The function to
         *     call to start the task. If the function returns a
         *     {@link promise.Promise}, this instance will wait for it to be
         *     resolved before starting the next task.
         * @param {string=} opt_description A description of the task.
         * @return {!promise.Promise<T>} A promise that will be resolved
         *     with the result of the action.
         * @template T
         */
        execute<T>(fn: () => T | Promise<T>, opt_description?: string): Promise<T>;

        /**
         * Inserts a {@code setTimeout} into the command queue. This is equivalent to
         * a thread sleep in a synchronous programming language.
         *
         * @param {number} ms The timeout delay, in milliseconds.
         * @param {string=} opt_description A description to accompany the timeout.
         * @return {!promise.Promise} A promise that will be resolved with
         *     the result of the action.
         */
        timeout(ms: number, opt_description?: string): Promise<void>;

        /**
         * Schedules a task that shall wait for a condition to hold. Each condition
         * function may return any value, but it will always be evaluated as a boolean.
         *
         * Condition functions may schedule sub-tasks with this instance, however,
         * their execution time will be factored into whether a wait has timed out.
         *
         * In the event a condition returns a Promise, the polling loop will wait for
         * it to be resolved before evaluating whether the condition has been satisfied.
         * The resolution time for a promise is factored into whether a wait has timed
         * out.
         *
         * If the condition function throws, or returns a rejected promise, the
         * wait task will fail.
         *
         * If the condition is defined as a promise, the flow will wait for it to
         * settle. If the timeout expires before the promise settles, the promise
         * returned by this function will be rejected.
         *
         * If this function is invoked with `timeout === 0`, or the timeout is omitted,
         * the flow will wait indefinitely for the condition to be satisfied.
         *
         * @param {(!promise.Promise<T>|function())} condition The condition to poll,
         *     or a promise to wait on.
         * @param {number=} opt_timeout How long to wait, in milliseconds, for the
         *     condition to hold before timing out. If omitted, the flow will wait
         *     indefinitely.
         * @param {string=} opt_message An optional error message to include if the
         *     wait times out; defaults to the empty string.
         * @return {!promise.Promise<T>} A promise that will be fulfilled
         *     when the condition has been satisified. The promise shall be rejected if
         *     the wait times out waiting for the condition.
         * @throws {TypeError} If condition is not a function or promise or if timeout
         *     is not a number >= 0.
         * @template T
         */
        wait<T>(condition: Promise<T> | Function, opt_timeout?: number, opt_message?: string): Promise<T>;
    }
}

/**
 * Defines a condition for use with WebDriver's WebDriver#wait wait command.
 */
export class Condition<T> {
    /**
     * @param {string} message A descriptive error message. Should complete the
     *     sentence 'Waiting [...]'
     * @param {function(!WebDriver): OUT} fn The condition function to
     *     evaluate on each iteration of the wait loop.
     */
    constructor(message: string, fn: (webdriver: WebDriver) => any);

    /** @return {string} A description of this condition. */
    description(): string;

    fn(webdriver: WebDriver): any;
}

/**
 * Defines a condition that will result in a {@link WebElement}.
 */
export class WebElementCondition extends Condition<WebElement> {
    // add an unused private member so the compiler treats this
    // class distinct from other Conditions
    private _nominal: undefined;
}

export namespace until {
    /**
     * Creates a condition that will wait until the input driver is able to switch
     * to the designated frame. The target frame may be specified as
     *
     * 1. a numeric index into
     *     [window.frames](https://developer.mozilla.org/en-US/docs/Web/API/Window.frames)
     *     for the currently selected frame.
     * 2. a {@link ./WebElement}, which must reference a FRAME or IFRAME
     *     element on the current page.
     * 3. a locator which may be used to first locate a FRAME or IFRAME on the
     *     current page before attempting to switch to it.
     *
     * Upon successful resolution of this condition, the driver will be left
     * focused on the new frame.
     *
     * @param {!(number|./WebElement|By|
     *           function(!./WebDriver): !./WebElement)} frame
     *     The frame identifier.
     * @return {!Condition<boolean>} A new condition.
     */
    function ableToSwitchToFrame(
        frame: number | WebElement | By | ((webdriver: WebDriver) => WebElement) | ByHash,
    ): Condition<boolean>;

    /**
     * Creates a condition that waits for an alert to be opened. Upon success, the
     * returned promise will be fulfilled with the handle for the opened alert.
     *
     * @return {!Condition<!./Alert>} The new condition.
     */
    function alertIsPresent(): Condition<Alert>;

    /**
     * Creates a condition that will wait for the given element to be disabled.
     *
     * @param {!WebElement} element The element to test.
     * @return {!WebElementCondition} The new condition.
     * @see WebDriver#isEnabled
     */
    function elementIsDisabled(element: WebElement): WebElementCondition;

    /**
     * Creates a condition that will wait for the given element to be enabled.
     *
     * @param {!WebElement} element The element to test.
     * @return {!WebElementCondition} The new condition.
     * @see WebDriver#isEnabled
     */
    function elementIsEnabled(element: WebElement): WebElementCondition;

    /**
     * Creates a condition that will wait for the given element to be deselected.
     *
     * @param {!WebElement} element The element to test.
     * @return {!WebElementCondition} The new condition.
     * @see WebDriver#isSelected
     */
    function elementIsNotSelected(element: WebElement): WebElementCondition;

    /**
     * Creates a condition that will wait for the given element to be in the DOM,
     * yet not visible to the user.
     *
     * @param {!WebElement} element The element to test.
     * @return {!WebElementCondition} The new condition.
     * @see WebDriver#isDisplayed
     */
    function elementIsNotVisible(element: WebElement): WebElementCondition;

    /**
     * Creates a condition that will wait for the given element to be selected.
     * @param {!WebElement} element The element to test.
     * @return {!WebElementCondition} The new condition.
     * @see WebDriver#isSelected
     */
    function elementIsSelected(element: WebElement): WebElementCondition;

    /**
     * Creates a condition that will wait for the given element to become visible.
     *
     * @param {!WebElement} element The element to test.
     * @return {!WebElementCondition} The new condition.
     * @see WebDriver#isDisplayed
     */
    function elementIsVisible(element: WebElement): WebElementCondition;

    /**
     * Creates a condition that will loop until an element is
     * {@link ./WebDriver#findElement found} with the given locator.
     *
     * @param {!(By|Function)} locator The locator to use.
     * @return {!WebElementCondition} The new condition.
     */
    function elementLocated(locator: Locator): WebElementCondition;

    /**
     * Creates a condition that will wait for the given element's
     * {@link WebDriver#getText visible text} to contain the given
     * substring.
     *
     * @param {!WebElement} element The element to test.
     * @param {string} substr The substring to search for.
     * @return {!WebElementCondition} The new condition.
     * @see WebDriver#getText
     */
    function elementTextContains(element: WebElement, substr: string): WebElementCondition;

    /**
     * Creates a condition that will wait for the given element's
     * {@link WebDriver#getText visible text} to match the given
     * {@code text} exactly.
     *
     * @param {!WebElement} element The element to test.
     * @param {string} text The expected text.
     * @return {!WebElementCondition} The new condition.
     * @see WebDriver#getText
     */
    function elementTextIs(element: WebElement, text: string): WebElementCondition;

    /**
     * Creates a condition that will wait for the given element's
     * {@link WebDriver#getText visible text} to match a regular
     * expression.
     *
     * @param {!WebElement} element The element to test.
     * @param {!RegExp} regex The regular expression to test against.
     * @return {!WebElementCondition} The new condition.
     * @see WebDriver#getText
     */
    function elementTextMatches(element: WebElement, regex: RegExp): WebElementCondition;

    /**
     * Creates a condition that will loop until at least one element is
     * {@link WebDriver#findElement found} with the given locator.
     *
     * @param {!(Locator|By.Hash|Function)} locator The locator
     *     to use.
     * @return {!Condition.<!Array.<!WebElement>>} The new
     *     condition.
     */
    function elementsLocated(locator: Locator): Condition<WebElement[]>;

    /**
     * Creates a condition that will wait for the given element to become stale. An
     * element is considered stale once it is removed from the DOM, or a new page
     * has loaded.
     *
     * @param {!WebElement} element The element that should become stale.
     * @return {!Condition<boolean>} The new condition.
     */
    function stalenessOf(element: WebElement): Condition<boolean>;

    /**
     * Creates a condition that will wait for the current page's title to contain
     * the given substring.
     *
     * @param {string} substr The substring that should be present in the page
     *     title.
     * @return {!Condition.<boolean>} The new condition.
     */
    function titleContains(substr: string): Condition<boolean>;

    /**
     * Creates a condition that will wait for the current page's title to match the
     * given value.
     *
     * @param {string} title The expected page title.
     * @return {!Condition<boolean>} The new condition.
     */
    function titleIs(title: string): Condition<boolean>;

    /**
     * Creates a condition that will wait for the current page's title to match the
     * given regular expression.
     *
     * @param {!RegExp} regex The regular expression to test against.
     * @return {!Condition.<boolean>} The new condition.
     */
    function titleMatches(regex: RegExp): Condition<boolean>;

    /**
     * Creates a condition that will wait for the current page's url to contain
     * the given substring.
     *
     * @param {string} substrUrl The substring that should be present in the current
     *     URL.
     * @return {!Condition<boolean>} The new condition.
     */
    function urlContains(substrUrl: string): Condition<boolean>;

    /**
     * Creates a condition that will wait for the current page's url to match the
     * given value.
     *
     * @param {string} url The expected page url.
     * @return {!Condition<boolean>} The new condition.
     */
    function urlIs(url: string): Condition<boolean>;

    /**
     * Creates a condition that will wait for the current page's url to match the
     * given regular expression.
     *
     * @param {!RegExp} regex The regular expression to test against.
     * @return {!Condition<boolean>} The new condition.
     */
    function urlMatches(regex: RegExp): Condition<boolean>;
}

export interface ILocation {
    x: number;
    y: number;
}

export interface ISize {
    width: number;
    height: number;
}

export interface IButton {
    LEFT: string;
    MIDDLE: string;
    RIGHT: string;
}

/**
 * Representations of pressable keys that aren't text.  These are stored in
 * the Unicode PUA (Private Use Area) code points, 0xE000-0xF8FF.  Refer to
 * http://www.google.com.au/search?&q=unicode+pua&btnG=Search
 */
export const Button: IButton;

export interface IKey {
    NULL: string;
    CANCEL: string; // ^break
    HELP: string;
    BACK_SPACE: string;
    TAB: string;
    CLEAR: string;
    RETURN: string;
    ENTER: string;
    SHIFT: string;
    CONTROL: string;
    ALT: string;
    PAUSE: string;
    ESCAPE: string;
    SPACE: string;
    PAGE_UP: string;
    PAGE_DOWN: string;
    END: string;
    HOME: string;
    ARROW_LEFT: string;
    LEFT: string;
    ARROW_UP: string;
    UP: string;
    ARROW_RIGHT: string;
    RIGHT: string;
    ARROW_DOWN: string;
    DOWN: string;
    INSERT: string;
    DELETE: string;
    SEMICOLON: string;
    EQUALS: string;

    NUMPAD0: string; // number pad keys
    NUMPAD1: string;
    NUMPAD2: string;
    NUMPAD3: string;
    NUMPAD4: string;
    NUMPAD5: string;
    NUMPAD6: string;
    NUMPAD7: string;
    NUMPAD8: string;
    NUMPAD9: string;
    MULTIPLY: string;
    ADD: string;
    SEPARATOR: string;
    SUBTRACT: string;
    DECIMAL: string;
    DIVIDE: string;

    F1: string; // function keys
    F2: string;
    F3: string;
    F4: string;
    F5: string;
    F6: string;
    F7: string;
    F8: string;
    F9: string;
    F10: string;
    F11: string;
    F12: string;

    COMMAND: string; // Apple command key
    META: string; // alias for Windows key

    /**
     * Simulate pressing many keys at once in a 'chord'. Takes a sequence of
     * keys or strings, appends each of the values to a string,
     * and adds the chord termination key ({@link Key.NULL}) and returns
     * the resulting string.
     *
     * Note: when the low-level webdriver key handlers see Keys.NULL, active
     * modifier keys (CTRL/ALT/SHIFT/etc) release via a keyup event.
     *
     * @param {...string} var_args The key sequence to concatenate.
     * @return {string} The null-terminated key sequence.
     */
    chord(...var_args: Array<string | IKey>): string;
}

/**
 * Representations of pressable keys that aren't text.  These are stored in
 * the Unicode PUA (Private Use Area) code points, 0xE000-0xF8FF.  Refer to
 * http://www.google.com.au/search?&q=unicode+pua&btnG=Search
 */
export const Key: IKey;

/**
 * Class for defining sequences of complex user interactions. Each sequence
 * will not be executed until {@link #perform} is called.
 *
 * Example:
 *
 *     new ActionSequence(driver).
 *         keyDown(Key.SHIFT).
 *         click(element1).
 *         click(element2).
 *         dragAndDrop(element3, element4).
 *         keyUp(Key.SHIFT).
 *         perform();
 */
export class ActionSequence {
    // region Constructors

    /**
     * @param {!WebDriver} driver The driver instance to use.
     */
    constructor(driver: WebDriver);

    // endregion

    // region Methods

    /**
     * Executes this action sequence.
     * @return {!promise.Promise} A promise that will be resolved once
     *     this sequence has completed.
     */
    perform(): promise.Promise<void>;

    /**
     * Moves the mouse.  The location to move to may be specified in terms of the
     * mouse's current location, an offset relative to the top-left corner of an
     * element, or an element (in which case the middle of the element is used).
     *
     * @param {(!./WebElement|{x: number, y: number})} location The
     *     location to drag to, as either another WebElement or an offset in
     *     pixels.
     * @param {{x: number, y: number}=} opt_offset If the target {@code location}
     *     is defined as a {@link ./WebElement}, this parameter defines
     *     an offset within that element. The offset should be specified in pixels
     *     relative to the top-left corner of the element's bounding box. If
     *     omitted, the element's center will be used as the target offset.
     * @return {!ActionSequence} A self reference.
     */
    mouseMove(location: WebElement | ILocation, opt_offset?: ILocation): ActionSequence;

    /**
     * Presses a mouse button. The mouse button will not be released until
     * {@link #mouseUp} is called, regardless of whether that call is made in this
     * sequence or another. The behavior for out-of-order events (e.g. mouseDown,
     * click) is undefined.
     *
     * If an element is provided, the mouse will first be moved to the center
     * of that element. This is equivalent to:
     *
     *     sequence.mouseMove(element).mouseDown()
     *
     * Warning: this method currently only supports the left mouse button. See
     * [issue 4047](http://code.google.com/p/selenium/issues/detail?id=4047).
     *
     * @param {(./WebElement|input.Button)=} opt_elementOrButton Either
     *     the element to interact with or the button to click with.
     *     Defaults to {@link input.Button.LEFT} if neither an element nor
     *     button is specified.
     * @param {input.Button=} opt_button The button to use. Defaults to
     *     {@link input.Button.LEFT}. Ignored if a button is provided as the
     *     first argument.
     * @return {!ActionSequence} A self reference.
     */
    mouseDown(opt_elementOrButton?: WebElement | string, opt_button?: string): ActionSequence;

    /**
     * Releases a mouse button. Behavior is undefined for calling this function
     * without a previous call to {@link #mouseDown}.
     *
     * If an element is provided, the mouse will first be moved to the center
     * of that element. This is equivalent to:
     *
     *     sequence.mouseMove(element).mouseUp()
     *
     * Warning: this method currently only supports the left mouse button. See
     * [issue 4047](http://code.google.com/p/selenium/issues/detail?id=4047).
     *
     * @param {(./WebElement|input.Button)=} opt_elementOrButton Either
     *     the element to interact with or the button to click with.
     *     Defaults to {@link input.Button.LEFT} if neither an element nor
     *     button is specified.
     * @param {input.Button=} opt_button The button to use. Defaults to
     *     {@link input.Button.LEFT}. Ignored if a button is provided as the
     *     first argument.
     * @return {!ActionSequence} A self reference.
     */
    mouseUp(opt_elementOrButton?: WebElement | string, opt_button?: string): ActionSequence;

    /**
     * Convenience function for performing a 'drag and drop' manuever. The target
     * element may be moved to the location of another element, or by an offset (in
     * pixels).
     *
     * @param {!./WebElement} element The element to drag.
     * @param {(!./WebElement|{x: number, y: number})} location The
     *     location to drag to, either as another WebElement or an offset in
     *     pixels.
     * @return {!ActionSequence} A self reference.
     */
    dragAndDrop(element: WebElement, location: WebElement | ILocation): ActionSequence;

    /**
     * Clicks a mouse button.
     *
     * If an element is provided, the mouse will first be moved to the center
     * of that element. This is equivalent to:
     *
     *     sequence.mouseMove(element).click()
     *
     * @param {(./WebElement|input.Button)=} opt_elementOrButton Either
     *     the element to interact with or the button to click with.
     *     Defaults to {@link input.Button.LEFT} if neither an element nor
     *     button is specified.
     * @param {input.Button=} opt_button The button to use. Defaults to
     *     {@link input.Button.LEFT}. Ignored if a button is provided as the
     *     first argument.
     * @return {!ActionSequence} A self reference.
     */
    click(opt_elementOrButton?: WebElement | string, opt_button?: string): ActionSequence;

    /**
     * Double-clicks a mouse button.
     *
     * If an element is provided, the mouse will first be moved to the center of
     * that element. This is equivalent to:
     *
     *     sequence.mouseMove(element).doubleClick()
     *
     * Warning: this method currently only supports the left mouse button. See
     * [issue 4047](http://code.google.com/p/selenium/issues/detail?id=4047).
     *
     * @param {(./WebElement|input.Button)=} opt_elementOrButton Either
     *     the element to interact with or the button to click with.
     *     Defaults to {@link input.Button.LEFT} if neither an element nor
     *     button is specified.
     * @param {input.Button=} opt_button The button to use. Defaults to
     *     {@link input.Button.LEFT}. Ignored if a button is provided as the
     *     first argument.
     * @return {!ActionSequence} A self reference.
     */
    doubleClick(opt_elementOrButton?: WebElement | string, opt_button?: string): ActionSequence;

    /**
     * Performs a modifier key press. The modifier key is <em>not released</em>
     * until {@link #keyUp} or {@link #sendKeys} is called. The key press will be
     * targetted at the currently focused element.
     * @param {!Key} key The modifier key to push. Must be one of
     *     {ALT, CONTROL, SHIFT, COMMAND, META}.
     * @return {!ActionSequence} A self reference.
     * @throws {Error} If the key is not a valid modifier key.
     */
    keyDown(key: string): ActionSequence;

    /**
     * Performs a modifier key release. The release is targetted at the currently
     * focused element.
     * @param {!Key} key The modifier key to release. Must be one of
     *     {ALT, CONTROL, SHIFT, COMMAND, META}.
     * @return {!ActionSequence} A self reference.
     * @throws {Error} If the key is not a valid modifier key.
     */
    keyUp(key: string): ActionSequence;

    /**
     * Simulates typing multiple keys. Each modifier key encountered in the
     * sequence will not be released until it is encountered again. All key events
     * will be targeted at the currently focused element.
     *
     * @param {...(string|!input.Key|!Array<(string|!input.Key)>)} var_args
     *     The keys to type.
     * @return {!ActionSequence} A self reference.
     * @throws {Error} If the key is not a valid modifier key.
     */
    sendKeys(...var_args: Array<string | promise.Promise<string>>): ActionSequence;

    // endregion
}

/**
 * Class for defining sequences of user touch interactions. Each sequence
 * will not be executed until {@link #perform} is called.
 *
 * Example:
 *
 *     new TouchSequence(driver).
 *         tapAndHold({x: 0, y: 0}).
 *         move({x: 3, y: 4}).
 *         release({x: 10, y: 10}).
 *         perform();
 */
export class TouchSequence {
    /*
     * @param {!WebDriver} driver The driver instance to use.
     * @constructor
     */
    constructor(driver: WebDriver);

    /**
     * Executes this action sequence.
     * @return {!promise.Promise} A promise that will be resolved once
     *     this sequence has completed.
     */
    perform(): promise.Promise<void>;

    /**
     * Taps an element.
     *
     * @param {!WebElement} elem The element to tap.
     * @return {!TouchSequence} A self reference.
     */
    tap(elem: WebElement): TouchSequence;

    /**
     * Double taps an element.
     *
     * @param {!WebElement} elem The element to double tap.
     * @return {!TouchSequence} A self reference.
     */
    doubleTap(elem: WebElement): TouchSequence;

    /**
     * Long press on an element.
     *
     * @param {!WebElement} elem The element to long press.
     * @return {!TouchSequence} A self reference.
     */
    longPress(elem: WebElement): TouchSequence;

    /**
     * Touch down at the given location.
     *
     * @param {{ x: number, y: number }} location The location to touch down at.
     * @return {!TouchSequence} A self reference.
     */
    tapAndHold(location: ILocation): TouchSequence;

    /**
     * Move a held {@linkplain #tapAndHold touch} to the specified location.
     *
     * @param {{x: number, y: number}} location The location to move to.
     * @return {!TouchSequence} A self reference.
     */
    move(location: ILocation): TouchSequence;

    /**
     * Release a held {@linkplain #tapAndHold touch} at the specified location.
     *
     * @param {{x: number, y: number}} location The location to release at.
     * @return {!TouchSequence} A self reference.
     */
    release(location: ILocation): TouchSequence;

    /**
     * Scrolls the touch screen by the given offset.
     *
     * @param {{x: number, y: number}} offset The offset to scroll to.
     * @return {!TouchSequence} A self reference.
     */
    scroll(offset: IOffset): TouchSequence;

    /**
     * Scrolls the touch screen, starting on `elem` and moving by the specified
     * offset.
     *
     * @param {!WebElement} elem The element where scroll starts.
     * @param {{x: number, y: number}} offset The offset to scroll to.
     * @return {!TouchSequence} A self reference.
     */
    scrollFromElement(elem: WebElement, offset: IOffset): TouchSequence;

    /**
   * Flick, starting anywhere on the screen, at speed xspeed and yspeed.
   *
   * @param {{xspeed: number, yspeed: number}} speed The speed to flick in each
   direction, in pixels per second.
   * @return {!TouchSequence} A self reference.
   */
    flick(speed: ISpeed): TouchSequence;

    /**
     * Flick starting at elem and moving by x and y at specified speed.
     *
     * @param {!WebElement} elem The element where flick starts.
     * @param {{x: number, y: number}} offset The offset to flick to.
     * @param {number} speed The speed to flick at in pixels per second.
     * @return {!TouchSequence} A self reference.
     */
    flickElement(elem: WebElement, offset: IOffset, speed: number): TouchSequence;
}

export interface IOffset {
    x: number;
    y: number;
}

export interface ISpeed {
    xspeed: number;
    yspeed: number;
}

/**
 * Represents a modal dialog such as {@code alert}, {@code confirm}, or
 * {@code prompt}. Provides functions to retrieve the message displayed with
 * the alert, accept or dismiss the alert, and set the response text (in the
 * case of {@code prompt}).
 */
export class Alert {
    /**
     * @param {!WebDriver} driver The driver controlling the browser this alert
     *     is attached to.
     * @param {string} text The message text displayed with this alert.
     */
    constructor(driver: WebDriver, text: string);

    // region Methods

    /**
     * Retrieves the message text displayed with this alert. For instance, if the
     * alert were opened with alert('hello'), then this would return 'hello'.
     * @return {!promise.Promise} A promise that will be resolved to the
     *     text displayed with this alert.
     */
    getText(): promise.Promise<string>;

    /**
     * Sets the username and password in an alert prompting for credentials (such
     * as a Basic HTTP Auth prompt). This method will implicitly
     * {@linkplain #accept() submit} the dialog.
     *
     * @param {string} username The username to send.
     * @param {string} password The password to send.
     * @return {!promise.Promise<void>} A promise that will be resolved when this
     *     command has completed.
     */
    authenticateAs(username: string, password: string): promise.Promise<void>;

    /**
     * Accepts this alert.
     * @return {!promise.Promise} A promise that will be resolved when
     *     this command has completed.
     */
    accept(): promise.Promise<void>;

    /**
     * Dismisses this alert.
     * @return {!promise.Promise} A promise that will be resolved when
     *     this command has completed.
     */
    dismiss(): promise.Promise<void>;

    /**
     * Sets the response text on this alert. This command will return an error if
     * the underlying alert does not support response text (e.g. window.alert and
     * window.confirm).
     * @param {string} text The text to set.
     * @return {!promise.Promise} A promise that will be resolved when
     *     this command has completed.
     */
    sendKeys(text: string): promise.Promise<void>;

    // endregion
}

/**
 * AlertPromise is a promise that will be fulfilled with an Alert. This promise
 * serves as a forward proxy on an Alert, allowing calls to be scheduled
 * directly on this instance before the underlying Alert has been fulfilled. In
 * other words, the following two statements are equivalent:
 *
 *     driver.switchTo().alert().dismiss();
 *     driver.switchTo().alert().then(function(alert) {
 *       return alert.dismiss();
 *     });
 *
 * @final
 */
export interface AlertPromise extends promise.IThenable<Alert> {}
export class AlertPromise extends Alert {
    /**
     * @param {!WebDriver} driver The driver controlling the browser this
     *     alert is attached to.
     * @param {!promise.Thenable<!Alert>} alert A thenable
     *     that will be fulfilled with the promised alert.
     */
    constructor(driver: WebDriver, alert: promise.Promise<Alert>);
}

/**
 * Recognized browser names.
 */
export interface IBrowser {
    ANDROID: string;
    CHROME: string;
    EDGE: string;
    FIREFOX: string;
    IE: string;
    INTERNET_EXPLORER: string;
    IPAD: string;
    IPHONE: string;
    OPERA: string;
    PHANTOM_JS: string;
    SAFARI: string;
    HTMLUNIT: string;
}

export const Browser: IBrowser;

export interface ProxyConfig {
    proxyType: string;
    proxyAutoconfigUrl?: string | undefined;
    ftpProxy?: string | undefined;
    httpProxy?: string | undefined;
    sslProxy?: string | undefined;
    noProxy?: string | undefined;
    socksProxy?: string | undefined;
    socksUsername?: string | undefined;
    socksPassword?: string | undefined;
}

/**
 * Creates new {@link WebDriver WebDriver} instances. The environment
 * variables listed below may be used to override a builder's configuration,
 * allowing quick runtime changes.
 *
 * - {@code SELENIUM_BROWSER}: defines the target browser in the form
 *   {@code browser[:version][:platform]}.
 *
 * - {@code SELENIUM_REMOTE_URL}: defines the remote URL for all builder
 *   instances. This en