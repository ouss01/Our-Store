'use strict'

// Do a two-pass walk, first to get the list of packages that need to be
// bundled, then again to get the actual files and folders.
// Keep a cache of node_modules content and package.json data, so that the
// second walk doesn't have to re-do all the same work.

const bundleWalk = require('npm-bundled')
const BundleWalker = bundleWalk.BundleWalker

const ignoreWalk = require('ignore-walk')
const IgnoreWalker = ignoreWalk.Walker

const rootBuiltinRules = Symbol('root-builtin-rules')
const packageNecessaryRules = Symbol('package-necessary-rules')
const path = require('path')

const normalizePackageBin = require('npm-normalize-package-bin')

// Weird side-effect of this: a readme (etc) file will be included
// if it exists anywhere within a folder with a package.json file.
// The original intent was only to include these files in the root,
// but now users in the wild are dependent on that behavior for
// localized documentation and other use cases.  Adding a `/` to
// these rules, while tempting and arguably more "correct", is a
// significant change that will break existing use cases.
const packageMustHaveFileNames = 'readme|copying|license|licence'

const packageMustHaves = `@(${packageMustHaveFileNames}){,.*[^~$]}`
const packageMustHavesRE = new RegExp(`^(${packageMustHaveFileNames})(\\..*[^~$])?$`, 'i')

const fs = require('fs')
const glob = require('glob')
const globify = pattern => pattern.split('\\').join('/')

const readOutOfTreeIgnoreFiles = (root, rel, result = '') => {
  for (const file of ['.npmignore', '.gitignore']) {
    try {
      const ignoreContent = fs.readFileSync(path.join(root, file), { encoding: 'utf8' })
      result += ignoreContent + '\n'
      // break the loop immediately after concatting, this allows us to prioritize the
      // .npmignore and discard the .gitignore if one exists
      break
    } catch (err) {
      // we ignore ENOENT errors completely because we don't care if the file doesn't exist
      // but we throw everything else because failing to read a file that does exist is
      // something that the user likely wants to know about. we don't need to test this.
      /* istanbul ignore next */
      if (err.code !== 'ENOENT') {
        throw err
      }
    }
  }

  if (!rel) {
    return result
  }

  const firstRel = rel.split(path.sep)[0]
  const newRoot = path.join(root, firstRel)
  const newRel = path.relative(newRoot, path.join(root, rel))

  return readOutOfTreeIgnoreFiles(newRoot, newRel, result)
}

const pathHasPkg = (input) => {
  if (!input.startsWith('node_modules/')) {
    return false
  }

  const segments = input.slice('node_modules/'.length).split('/', 2)
  return segments[0].startsWith('@')
    ? segments.length === 2
    : true
}

const pkgFromPath = (input) => {
  const segments = input.slice('node_modules/'.length).split('/', 2)
  return segments[0].startsWith('@')
    ? segments.join('/')
    : segments[0]
}

const defaultRules = [
  '.npmignore',
  '.gitignore',
  '**/.git',
  '**/.svn',
  '**/.hg',
  '**/CVS',
  '**/.git/**',
  '**/.svn/**',
  '**/.hg/**',
  '**/CVS/**',
  '/.lock-wscript',
  '/.wafpickle-*',
  '/build/config.gypi',
  'npm-debug.log',
  '**/.npmrc',
  '.*.swp',
  '.DS_Store',
  '**/.DS_Store/**',
  '._*',
  '**/._*/**',
  '*.orig',
  '/package-lock.json',
  '/yarn.lock',
  '/pnpm-lock.yaml',
  '/archived-packages/**',
]

// There may be others, but :?|<> are handled by node-tar
const nameIsBadForWindows = file => /\*/.test(file)

class Walker extends IgnoreWalker {
  constructor (opt) {
    opt = opt || {}

    // the order in which rules are applied.
    opt.ignoreFiles = [
      rootBuiltinRules,
      'package.json',
      '.npmignore',
      '.gitignore',
      packageNecessaryRules,
    ]

    opt.includeEmpty = false
    opt.path = opt.path || process.cwd()

    // only follow links in the root node_modules folder, because if those
    // folders are included, it's because they're bundled, and bundles
    // should include the contents, not the symlinks themselves.
    // This regexp tests to see that we're either a node_modules folder,
    // or a @scope within a node_modules folder, in the root's node_modules
    // hierarchy (ie, not in test/foo/node_modules/ or something).
    const followRe = /^(?:\/node_modules\/(?:@[^/]+\/[^/]+|[^/]+)\/)*\/node_modules(?:\/@[^/]+)?$/
    const rootPath = opt.parent ? opt.parent.root : opt.path
    const followTestPath = opt.path.replace(/\\/g, '/').slice(rootPath.length)
    opt.follow = followRe.test(followTestPath)

    super(opt)

    // ignore a bunch of things by default at the root level.
    // also ignore anything in the main project node_modules hierarchy,
    // except bundled dependencies
    if (this.isProject) {
      this.bundled = opt.bundled || []
      this.bundledScopes = Array.from(new Set(
        this.bundled.filter(f => /^@/.test(f))
          .map(f => f.split('/')[0])))
      this.packageJsonCache = this.parent ? this.parent.packageJsonCache
        : (opt.packageJsonCache || new Map())
      let rules = defaultRules.join('\n') + '\n'

      if (opt.prefix && opt.workspaces) {
        const gPath = globify(opt.path)
        const gPrefix = globify(opt.prefix)
        const gWorkspaces = opt.workspaces.map((ws) => globify(ws))
        // if opt.path and opt.prefix are not the same directory, and opt.workspaces has opt.path
        // in it, then we know that opt.path is a workspace directory. in order to not drop ignore
        // rules from directories between the workspace root (opt.prefix) and the workspace itself
        // (opt.path), we need to find and read those now
        /* istanbul ignore else */
        if (gPath !== gPrefix && gWorkspaces.includes(gPath)) {
          // relpath is the relative path between the prefix and the parent of opt.path
          // we use the parent because ignore-walk will read the files in opt.path already
          const relpath = path.relative(opt.prefix, path.dirname(opt.path))
          rules += readOutOfTreeIgnoreFiles(opt.prefix, relpath)
        } else if (gPath === gPrefix) {
          // on the other hand, if the path and the prefix are the same, then we ignore workspaces
          // so that we don't pack workspaces inside of a root project
          rules += opt.workspaces.map((ws) => globify(path.relative(opt.path, ws))).join('\n')
        }
      }

      super.onReadIgnoreFile(rootBuiltinRules, rules, _ => _)
    } else {
      this.bundled = []
      this.bundledScopes = []
      this.packageJsonCache = this.parent.packageJsonCache
    }
  }

  get isProject () {
    return !this.parent || this.parent.follow && this.isSymbolicLink
  }

  onReaddir (entries) {
    if (this.isProject) {
      entries = entries.filter(e =>
        e !== '.git' &&
        !(e === 'node_modules' && this.bundled.length === 0)
      )
    }

    // if we have a package.json, then look in it for 'files'
    // we _only_ do this in the root project, not bundled deps
    // or other random folders.  Bundled deps are always assumed
    // to be in the state the user wants to include them, and
    // a package.json somewhere else might be a template or
    // test or something else entirely.
    if (!this.isProject || !entries.includes('package.json')) {
      return super.onReaddir(entries)
    }

    // when the cache has been seeded with the root manifest,
    // we must respect that (it may differ from the filesystem)
    const ig = path.resolve(this.path, 'package.json')

    if (this.packageJsonCache.has(ig)) {
      const pkg = this.packageJsonCache.get(ig)

      // fall back to filesystem when seeded manifest is invalid
      if (!pkg || typeof pkg !== 'object') {
        return this.readPackageJson(entries)
      }

      // feels wonky, but this ensures package bin is _always_
      // normalized, as well as guarding against invalid JSON
      return this.getPackageFiles(entries, JSON.stringify(pkg))
    }

    this.readPackageJson(entries)
  }

  onReadPackageJson (entries, er, pkg) {
    if (er) {
      this.emit('error', er)
    } else {
      this.getPackageFiles(entries, pkg)
    }
  }

  mustHaveFilesFromPackage (pkg) {
    const files = []
    if (pkg.browser) {
      files.push('/' + pkg.browser)
    }
    if (pkg.main) {
      files.push('/' + pkg.main)
    }
    if (pkg.bin) {
      // always an o