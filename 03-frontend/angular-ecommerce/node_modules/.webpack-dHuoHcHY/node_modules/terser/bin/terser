#!/usr/bin/env node
// -*- js -*-
/* eslint-env node */

"use strict";

require("../tools/exit.js");

var fs = require("fs");
var info = require("../package.json");
var path = require("path");
var program = require("commander");

var Terser = require("..");
try {
    require("source-map-support").install();
} catch (err) {}

const skip_keys = new Set([ "cname", "parent_scope", "scope", "uses_eval", "uses_with", "_var_name_cache" ]);
var files = {};
var options = {
    compress: false,
    mangle: false
};
program.version(info.name + " " + info.version);
program.parseArgv = program.parse;
program.parse = undefined;
if (process.argv.includes("ast")) program.helpInformation = describe_ast;
else if (process.argv.includes("options")) program.helpInformation = function() {
    var text = [];
    var options = Terser.default_options();
    for (var option in options) {
        text.push("--" + (option === "output" ? "beautify" : option === "sourceMap" ? "source-map" : option) + " options:");
        text.push(format_object(options[option]));
        text.push("");
    }
    return text.join("\n");
};
program.option("-p, --parse <options>", "Specify parser options.", parse_js());
program.option("-c, --compress [options]", "Enable compressor/specify compressor options.", parse_js());
program.option("-m, --mangle [options]", "Mangle names/specify mangler options.", parse_js());
program.option("--mangle-props [options]", "Mangle properties/specify mangler options.", parse_js());
program.option("-b, --beautify [options]", "Beautify output/specify output options.", parse_js());
program.option("-o, --output <file>", "Output file (default STDOUT).");
program.option("--comments [filter]", "Preserve copyright comments in the output.");
program.option("--config-file <file>", "Read minify() options from JSON file.");
program.option("-d, --define <expr>[=value]", "Global definitions.", parse_js("define"));
program.option("--ecma <version>", "Specify ECMAScript release: 5, 2015, 2016 or 2017...");
program.option("-e, --enclose [arg[,...][:value[,...]]]", "Embed output in a big function with configurable arguments and values.");
program.option("--ie8", "Support non-standard Internet Explorer 8.");
program.option("--keep-classnames", "Do not mangle/drop class names.");
program.option("--keep-fnames", "Do not mangle/drop function names. Useful for code relying on Function.prototype.name.");
program.option("--module", "Input is an ES6 module");
program.option("--name-cache <file>", "File to hold mangled name mappings.");
program.option("--rename", "Force symbol expansion.");
program.option("--no-rename", "Disable symbol expansion.");
program.option("--safari10", "Support non-standard Safari 10.");
program.option("--source-map [options]", "Enable source map/specify source map options.", parse_js());
program.option("--timings", "Display operations run time on STDERR.");
program.option("--toplevel", "Compress and/or mangle variables in toplevel scope.");
program.option("--verbose", "Print diagnostic messages.");
program.option("--warn", "Print warning messages.");
program.option("--wrap <name>", "Embed everything as a function with “exports” corresponding to “name” globally.");
program.arguments("[files...]").parseArgv(process.argv);
if (program.configFile) {
    options = JSON.parse(read_file(program.configFile));
}
if (!program.output && program.sourceMap && program.sourceMap.url != "inline") {
    fatal("ERROR: cannot write source map to STDOUT");
}
[
    "compress",
    "enclose",
    "ie8",
    "mangle",
    "module",
    "safari10",
    "sourceMap",
    "toplevel",
    "wrap"
].forEach(function(name) {
    if (name in program) {
        options[name] = program[name];
    }
});
if ("ecma" in program) {
    if (program.ecma != (program.ecma | 0)) fatal("ERROR: ecma must be an integer");
    const ecma = program.ecma | 0;
    if (ecma > 5 && ecma < 2015)
        options.ecma = ecma + 2009;
    else
        options.ecma = ecma;
}
if (program.beautify) {
    options.output = typeof program.beautify == "object" ? program.beautify : {};
    if (!("beautify" in options.output)) {
        options.output.beautify = true;
    }
}
if (program.comments) {
    if (typeof options.output != "object") options.output = {};
    options.output.comments = typeof program.comments == "string" ? (program.comments == "false" ? false : program.comments) : "some";
}
if (program.define) {
    if (typeof options.compress != "object") options.compress = {};
    if (typeof options.compress.global_defs != "object") options.compress.global_defs = {};
    for (var expr in program.define) {
        options.compress.global_defs[expr] = program.define[expr];
    }
}
if (program.keepClassnames) {
    options.keep_classnames = true;
}
if (program.keepFnames) {
    options.keep_fnames = true;
}
if (program.mangleProps) {
    if (program.mangleProps.domprops) {
        delete program.mangleProps.domprops;
    } else {
        if (typeof program.mangleProps != "object") program.mangleProps = {};
        if (!Array.isArray(program.mangleProps.reserved)) program.mangleProps.reserved = [];
    }
    if (typeof options.mangle != "object") options.mangle = {};
    options.mangle.properties = program.mangleProps;
}
if (program.nameCache) {
    options.nameCache = JSON.parse(read_file(program.nameCache, "{}"));
}
if (program.output == "ast") {
    options.output = {
        ast: true,
        code: false
    };
}
if (program.parse) {
    if (!program.parse.acorn && !program.parse.spidermonkey) {
        options.parse = program.parse;
    } else if (program.sourceMap && program.sourceMap.content == "inline") {
        fatal("ERROR: inline source map only works with built-in parser");
    }
}
if (~program.rawArgs.indexOf("--rename")) {
    options.rename = true;
} else if (!program.rename) {
    options.rename = false;
}
var convert_path = function(name) {
    return name;
};
if (typeof program.sourceMap == "object" && "base" in program.sourceMap) {
    convert_path = function() {
        var base = program.sourceMap.base;
        delete options.sourceMap.base;
        return function(name) {
            return path.relative(base, name);
        };
    }();
}
if (program.verbose) {
    options.warnings = "verbose";
} else if (program.warn) {
    options.warnings = true;
}

let filesList;
if (options.files && options.files.length) {
    filesList = options.files;

    delete options.files;
} else if (program.args.length) {
    filesList = program.args;
}

if (filesList) {
    simple_glob(filesList).forEach(function(name) {
        files[convert_path(name)] = read_file(name);
    });
    run();
} else {
    var chunks = [];
    process.stdin.setEncoding("utf8");
    process.stdin.on("data", function(chunk) {
        chunks.push(chunk);
    }).on("end", function() {
        files = [ chunks.join("") ];
        run();
    });
    process.stdin.resume();
}

function convert_ast(fn) {
    return Terser.AST_Node.from_mozilla_ast(Object.keys(files).reduce(fn, null));
}

function run() {
    Terser.AST_Node.warn_function = function(msg) {
        print_error("WARN: " + msg);
    };
    var content = program.sourceMap && program.sourceMap.content;
    if (content && content !== "inline") {
        options.sourceMap.content = read_file(content, content);
    }
    if (program.timings) options.timings = true;
    try {
        if (program.parse) {
            if (program.parse.acorn) {
                files = convert_ast(function(toplevel, name) {
                    return require("acorn").parse(files[name], {
                        ecmaVersion: 2018,
                        locations: true,
                        program: toplevel,
                        sourceFile: name,
                        sourceType: options.module || program.parse.module ? "module" : "script"
                    });
                });
            } else if (program.parse.spidermonkey) {
                files = convert_ast(function(toplevel, name) {
                    var obj = JSON.parse(files[name]);
                    if (!toplevel) return obj;
                    toplevel.body = toplevel.body.concat(obj.body);
                    return toplevel;
                });
            }
        }
    } catch (ex) {
        fatal(ex);
    }
    var result = Terser.minify(files, options);
    if (result.error) {
        var ex = result.error;
        if (ex.name == "SyntaxError") {
            print_error("Parse error at " + ex.filename + ":" + ex.line + "," + ex.col);
            var col = ex.col;
            var lines = files[ex.filename].split(/\r?\n/);
            var line = lines[ex.line - 1];
            if (!line && !col) {
                line = lines[ex.line - 2];
                col = line.length;
            }
            if (line) {
                var limit = 70;
                if (col > limit) {
                    line = line.slice(col - limit);
                    col = limit;
                }
                print_error(line.slice(0, 80));
                print_error(line.slice(0, col).replace(/\S/g, " ") + "^");
            }
        }
        if (ex.defs) {
            print_error("Supported options:");
            print_error(format_object(ex.defs));
        }
        fatal(ex);
    } else if (program.output == "ast") {
        if (!options.compress && !options.mangle) {
            result.ast.figure_out_scope({});
        }
        print(JSON.stringify(result.ast, function(key, value) {
            if (value) switch (key) {
              case "thedef":
                return symdef(value);
              case "enclosed":
                return value.length ? value.map(symdef) : undefined;
              case "variables":
              case "functions":
              case "globals":
                return value.size ? collect_from_map(value, symdef) : undefined;
            }
            if (skip_keys.has(key)) return;
            if (value instanceof Terser.AST_Token) return;
            if (value instanceof Map) return;
            if (value instanceof Terser.AST_Node) {
                var result = {
                    _class